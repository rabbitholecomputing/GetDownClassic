// ===========================================================================//	CBasicApp.cp 				©1994-1999 Metrowerks Inc. All rights reserved.// ===========================================================================//	This file contains the starter code for a basic PowerPlant project#include "CBasicApp.h"#define kAppYieldQuantum -1// ===========================================================================//	¥ main// ===========================================================================CDownloadClient downloadClient;#define Debug_Throwint main(){					// Set Debugging options	SetDebugThrow_(debugAction_Alert);	SetDebugSignal_(debugAction_Alert);	// Initialize Memory Manager. Parameter is the number of	// master pointer blocks to allocate	InitializeHeap(16);		// Initialize standard Toolbox managers	UQDGlobals::InitializeToolbox(&qd);		// Install a GrowZone to catch low-memory situations		new LGrowZone(20000);		// Try initializing TCP.	try	{		LTCPEndpoint *tcp = UNetworkFactory::CreateTCPEndpoint(8192);		if(tcp == NULL)		{			// No TCP, no program.			::StopAlert(rALRT_NoNetworking, nil);			::ExitToShell();		}	}	catch (...)	{		// No TCP, no program.		::StopAlert(rALRT_NoNetworking, nil);		::ExitToShell();	}		// Thread!	if(UEnvironment::HasFeature(env_HasThreadsManager))		new UMainThread;	else	{		// No threading, no program.		::StopAlert(rALRT_NoThreadManager, nil);		::ExitToShell();	}	// Create the application object and run.	CBasicApp theApp;	theApp.Run();		return 0;}// ---------------------------------------------------------------------------//	¥ CBasicApp										[public]// ---------------------------------------------------------------------------//	Application object constructorCBasicApp::CBasicApp(){	RegisterClasses();}// ---------------------------------------------------------------------------//	¥ ~CBasicApp									[public, virtual]// ---------------------------------------------------------------------------//	Application object destructorCBasicApp::~CBasicApp(){	// Nothing}// ---------------------------------------------------------------------------//	¥ StartUp										[protected, virtual]// ---------------------------------------------------------------------------//	Perform an action in response to the Open Application AppleEvent.//	Here, issue the New command to open a window.voidCBasicApp::StartUp(){	ObeyCommand(cmd_New, nil);}// ---------------------------------------------------------------------------//	¥ ObeyCommand									[public, virtual]// ---------------------------------------------------------------------------//	Respond to Commands. Returns true if the Command was handled, false if not.BooleanCBasicApp::ObeyCommand(	CommandT	inCommand,	void*		ioParam){	Boolean		cmdHandled = true;	// Assume we'll handle the command	switch (inCommand) {		case cmd_New: {			// Actions to take when starting the application.			theWindow = LWindow::CreateWindow(PPob_SampleWindow, this);			ThrowIfNil_(theWindow);			UReanimator::LinkListenerToControls(this, theWindow, rRidL_SampleWindow);							UpdateDownloadButtons();						downloadLockout = false;					theWindow->Show();						break;		}				case cmd_Preferences: {			prefsDialog.ShowPreferences();			UpdateDownloadButtons();			break;		}				case cmd_JustifyLeft: {			// Batch Download...			batchDownloadDialog.SetParent(this);			batchDownloadDialog.Show();			break;		}				default: {			cmdHandled = LApplication::ObeyCommand(inCommand, ioParam);			break;		}	}		return cmdHandled;}// ---------------------------------------------------------------------------//	¥ FindCommandStatus								[public, virtual]// ---------------------------------------------------------------------------//	Determine the status of a Command for the purposes of menu updating.voidCBasicApp::FindCommandStatus(	CommandT	inCommand,	Boolean&	outEnabled,	Boolean&	outUsesMark,	UInt16&		outMark,	Str255		outName){	switch (inCommand) {		case cmd_New: {			outEnabled = true;			break;		}				case cmd_Preferences: {			outEnabled = true;			break;		}				case mcmd_Preset1:		case mcmd_Preset2:		case mcmd_Preset3:		case mcmd_Preset4:		case mcmd_Preset5:		case mcmd_Preset6:		case mcmd_Preset7:		case mcmd_Preset8:		{			outEnabled = true;			break;		}			case cmd_JustifyLeft: {			outEnabled = true;			break;		}			default: {			LApplication::FindCommandStatus(inCommand, outEnabled,											outUsesMark, outMark, outName);			break;		}	}}// ---------------------------------------------------------------------------//	¥ RegisterClasses								[protected]// ---------------------------------------------------------------------------//	To reduce clutter within the Application object's constructor, class//	registrations appear here in this seperate function for ease of use.voidCBasicApp::RegisterClasses(){	RegisterClass_(LWindow);	RegisterClass_(LCaption);	RegisterClass_(LEditField);	RegisterClass_(LTabGroup);	RegisterClass_(LStdButton);	RegisterClass_(LDialogBox);	RegisterClass_(LStdCheckBox);	RegisterClass_(LGroupBox);	RegisterClass_(LTable);	RegisterClass_(CUrlPresetTable);	RegisterClass_(CProgressBar);	RegisterClass_(LView);	RegisterClass_(LScroller);	RegisterClass_(CBatchDownloadUrlTable);	RegisterClass_(LActiveScroller);	RegisterClass_(LStdRadioButton);	RegisterClass_(LRadioGroup);		// This thread automatically yields to other threads.	AddAttachment(new LYieldAttachment(kAppYieldQuantum));}Boolean	CBasicApp::HandleKeyPress(const EventRecord& inKeyEvent){	Boolean handled = false;	// Key down, key was RETURN or ENTER, not locked out.	if(inKeyEvent.what == 3)		if((inKeyEvent.message & 0xFF) == 0x0D || (inKeyEvent.message & 0xFF) == 0x03)		{			if(downloadLockout == false) InitiateDownload();		}		return handled;}/* The message handler for the app. */void CBasicApp::ListenToMessage(MessageT inMessage, void *ioParam){	// We got a message of some sort - is it anything the application cares about?	switch(inMessage)	{		case msg_DownloadButton:			// The Download button was pressed. Either cancel or initiate depending on state.			downloadLockout ? CancelDownload() : InitiateDownload();			break;					case msg_UpdateProgressBar:			// Event from the download thread.			CProgressBar *mProgressBar = dynamic_cast<CProgressBar *>(theWindow->FindPaneByID(pane_ProgBar_Progress));			mProgressBar->SetPercentage((UInt32)ioParam);						GetWindow()->FindPaneByID(pane_ProgBar_Progress)->Refresh();			GetWindow()->FindPaneByID(pane_ProgBar_Progress)->UpdatePort();						break;				case msg_UpdateProgressText:			// Event from the download thread.			LCaption *mProgress = dynamic_cast<LCaption *>(theWindow->FindPaneByID(pane_Caption_Status));			mProgress->SetDescriptor((StringPtr)ioParam);						GetWindow()->FindPaneByID(pane_Caption_Status)->Refresh();			GetWindow()->FindPaneByID(pane_Caption_Status)->UpdatePort();			break;					case msg_IllegalRedirect:			// Event from the download thread.			// Don't worry about any other state actions, the download thread terminating will kick them off.			UModalAlerts::StopAlert(rALRT_HTTPSRedirect);			break;					case mcmd_Preset1:		case mcmd_Preset2:		case mcmd_Preset3:		case mcmd_Preset4:		case mcmd_Preset5:		case mcmd_Preset6:		case mcmd_Preset7:		case mcmd_Preset8:		case mcmd_Preset9:		case mcmd_Preset10:		{			// Grab the preset info from the preferences data and populate the URL field.			LEditField *mSourceUrl;			SInt16 presetIndex = inMessage - mcmd_PresetBegin;			mSourceUrl = dynamic_cast<LEditField *>(theWindow->FindPaneByID(pane_EditField_SourceURL));			mSourceUrl->SetDescriptor(prefsDialog.GetUrlPreset(presetIndex)->url);			break;		}				case msg_DLAttemptInProgress:		{			// A download attempt has been started.			// Change the Download button to Stop and don't allow any more downloads to begin.			LStdButton *btnDownload = dynamic_cast<LStdButton *>(theWindow->FindPaneByID(pane_Button_Download));			LStr255 stop(strN_UIStrings, strN_UI_Stop);			btnDownload->SetDescriptor(stop);			btnDownload->Refresh();			downloadLockout = true;			break;		}				case msg_DLAttemptComplete:		{			// A download attempt has ended.			// Change the Stop button to Download and allow downloads again.			LStdButton *btnDownload = dynamic_cast<LStdButton *>(theWindow->FindPaneByID(pane_Button_Download));			LStr255 dl(strN_UIStrings, strN_UI_Download);			btnDownload->SetDescriptor(dl);			btnDownload->Refresh();			downloadLockout = false;						// If we're batch downloading.			if(batchDownloadDialog.IsBatchDownloading())			{				batchDownloadDialog.SetCurrentDownloadStatus((DOWNLOAD_STATE)ioParam);				theWindow->Draw(nil);			}			break;		}				case msg_DLSuccess:			bLastDownloadSuccess = true;			iLastDownloadError = noErr;			break;					case msg_DLFailure:			bLastDownloadSuccess = false;			iLastDownloadError = (short)ioParam;			break;					case msg_BatchContinue:			batchDownloadDialog.NextDownloadCanBegin();			break;	}}void CBasicApp::UpdateDownloadButtons(){	/* Update the labels for the download preset buttons. */	LStdButton *mBtn;	for(int i=0; i<8; i++)	{		mBtn = dynamic_cast<LStdButton *>(theWindow->FindPaneByID(100+i));		mBtn->SetDescriptor(prefsDialog.GetUrlPreset(i)->name);	}}void CBasicApp::InitiateDownload(){	LEditField *mSourceUrl;	Str255 strRemoteUrl;		mSourceUrl = dynamic_cast<LEditField *>(theWindow->FindPaneByID(pane_EditField_SourceURL));	mSourceUrl->GetDescriptor(strRemoteUrl);	Str255 strRemoteFilename;	CUrlHelper::GetRemoteFilename(strRemoteFilename, strRemoteUrl);		if(strRemoteFilename[0] == 0)	{		// error out here	}	else	{		if(IsBatchDownloading() == false)		{			downloadClient.BeginDownloadProcess(this, prefsDialog.GetCurrentPreferences(), strRemoteUrl);		}		else		{			downloadClient.BeginDownloadProcess(this, prefsDialog.GetCurrentPreferences(),												strRemoteUrl,												IsBatchDownloading(),												false,												batchDownloadDialog.GetDestination());		}		}}void CBasicApp::CancelDownload(){	downloadClient.StopDownloadProcess();}