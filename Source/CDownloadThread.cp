#include "CDownloadThread.h"#include "CDownloadClient.h"#include "CBasicApp.h"char statusText[255];Str255 pStatusText;/* Thread class */CDownloadThread::~CDownloadThread(){	delete mConnection;}CDownloadThread::CDownloadThread(LTCPEndpoint *inEndpoint, 									ConstStr255Param userAgent, 									Boolean decodeMacBinary, 									ConstStr255Param url, 									ConstStr255Param remoteFilename,									FSSpec *presetDestination,									Boolean overwriteLocal,									LListener *theListener,									LInternetAddress *inRemoteAddress,									ConstStr255Param remotePath,									Boolean saveFile									) 	: LThread(false, thread_DefaultStack, threadOption_Default, nil){	oEndpoint = inEndpoint;	LStr255::CopyPStr(url, pRemoteUrl);	LStr255::CopyPStr(remotePath, pRemotePath);	LStr255::CopyPStr(remoteFilename, pRemoteFilename);	oInterestedParty = theListener;		pUserAgent = userAgent;		bOverrideStatusMsg = false;	bFileDownloadInProgress = false;	bDecodeMacBinary = decodeMacBinary;	bMacBinaryWasDecoded = false;	bOverwriteLocal = overwriteLocal;	bSavingFile = saveFile;	memcpy(&mRemoteAddress, inRemoteAddress, sizeof(LInternetAddress));		if(presetDestination != nil)	{		memcpy(&mDestination, presetDestination, sizeof(FSSpec));		bDestinationIsGood = true;	}	else	{		bDestinationIsGood = false;	}		this->mConnection = new LHTTPConnection(*this);	// using this thread for the connection stuff}							void *CDownloadThread::Run(){	Str255 remoteHost, redirectDestination;	LHTTPMessage httpMessage;			mConnection->SetTimeoutSeconds(5);	mConnection->AddListener(this);		AddListener(oInterestedParty);	StartBroadcasting();	BroadcastMessage(msg_DLAttemptInProgress, NULL);		// Get these values for our download.	//LInternetAddress *remoteAddress = oMaster->GetRemoteAddress();	mRemoteAddress.GetDNSDescriptor(remoteHost, false);		UpdateProgressBar(0);	try	{			iRedirectsRemaining = kMaxRedirectsToAllow;		bool bIsRedirected;		bSuccess = false;				while(true)		{					bIsRedirected = false;					// Header fields.			char tmpString[256];			CopyPascalStringToC(remoteHost, tmpString);			httpMessage.AddArbitraryField("Host", tmpString);						CopyPascalStringToC(pUserAgent, tmpString);			httpMessage.SetUserAgent(tmpString);						// Perform the connection.			mConnection->Get(remoteHost, pRemotePath, httpMessage, mHttpResponse, mRemoteAddress.GetHostPort());					if(mHttpResponse.GetResponseCode() == kHTTP_Response_MovedPermanently ||				mHttpResponse.GetResponseCode() == kHTTP_Response_MovedTemporarily)			{				// Do it again with the new remote path.				LHTTPMessage *redirectMsg; 				LHeaderField location;								redirectMsg = mHttpResponse.GetReturnMessage();				redirectMsg->GetArbitraryField("Location", &location);				CopyCStringToPascal(location.GetBody(), redirectDestination);					if(!CUrlHelper::IsHttpAddress(redirectDestination))				{					bOverrideStatusMsg = true;					DisplayProgress(p2cstr(LStr255(strN_ConnectionMsgs, strN_Conn_HTTPSRedirect)));					UpdateProgressBar(0);										bSuccess = false;					break;				}								UInt16 port;				CUrlHelper::GetRemoteHostname(remoteHost, &port, redirectDestination);				CUrlHelper::GetRemotePath(pRemotePath, redirectDestination);				mRemoteAddress.SetDNSAddress(remoteHost);				mRemoteAddress.SetHostPort(port);				bIsRedirected = true;								iRedirectsRemaining--;			}						// Exit condition: Out of redirects			if(iRedirectsRemaining == 0)			{				bSuccess = false;				break;			}						// Exit condition: No redirect.			if(bIsRedirected == false)			{				bSuccess = (mHttpResponse.GetResponseCode() == 200);				break;			}		}				// The download is complete, either success or failure.		if(bSuccess)		{				// The download completed successfully.			if(bSavingFile == false)			{				// We're not saving the file. Copy it to a new buffer and tell				// our interested party that it's available.				LDynamicBuffer *responseBuf = mHttpResponse.GetReturnMessage()->GetInternalMessageBody();				Handle retrievedFile = NewHandle(responseBuf->GetBufferLength());				responseBuf->BufferToHandle(retrievedFile);				BroadcastMessage(msg_DLDataAvailable, retrievedFile);			}			else			{				// Make sure the user didn't cancel the destination dialog!				// We might have completed a small download during that time...				if(!bDestinationIsGood) CleanupDownloadAttempt();							ProcessDownloadedFile(&mHttpResponse);								Str255 tmp;				CUrlHelper::GetRemoteFilename(tmp, pRemotePath);				UInt32 kb = iFileSize/1024;				UInt32 seconds = lround((float)iElapsedTicks / 60.0);								if(iDownloadSaveResult != noErr)				{					if(iDownloadSaveResult == -34)					{						// Disk is full.						sprintf(statusText, "Unable to save the downloaded file because the disk is full. (Error -34)");						DisplayProgress(statusText);					}					else if(iDownloadSaveResult == -48)					{						// Disk is full.						sprintf(statusText, "This file was skipped because it already exists locally.");						DisplayProgress(statusText);					}				}				else				{					if(bMacBinaryWasDecoded)					{						sprintf(statusText, p2cstr(LStr255(strN_Progress, strN_Prog_CompletedMB)), tmp, kb, seconds);					}					else					{						switch(iMacBinaryDecodeResult)						{							case dupFNErr:								// Didn't decode MacBinary file.								sprintf(statusText, p2cstr(LStr255(strN_Progress, strN_Prog_CompletedMBExists)), tmp, kb, seconds);								break;							case noErr:								// Didn't decode it and didn't try.								sprintf(statusText, p2cstr(LStr255(strN_Progress, strN_Prog_Completed)), tmp, kb, seconds);								break;							default:								// Some other error during decoding.								sprintf(statusText, p2cstr(LStr255(strN_Progress, strN_Prog_CompletedMBFailed)), tmp, kb, seconds, iMacBinaryDecodeResult);								break;						}					}					DisplayProgress(statusText);				}						}		}	}	catch (LException e)	{			if(mState != DS_CANCELLED)		{			if(e.GetErrorCode() == kOTNoDataErr)			{				sprintf(statusText, "%s (error %ld)", p2cstr(LStr255(132, 1)), e.GetErrorCode());			}			else if(e.GetErrorCode() == -10000)			{				sprintf(statusText, "Sorry, the system volume is too full to download this file. Please free some space on your system volume and try again.");			}			else			{				sprintf(statusText, "%s (error %ld)", p2cstr(LStr255(132, 2)), e.GetErrorCode());			}					}		else if(mState == DS_CANCELLED)		{			sprintf(statusText, p2cstr(LStr255(strN_Progress, strN_Prog_Cancelled)));			DisplayProgress(statusText);		}				DisplayProgress(statusText);	}	CleanupDownloadAttempt();	mDownloadFile.CloseDataFork();		return nil;}void CDownloadThread::CleanupDownloadAttempt(){	// Stuff to execute before the thread terminates.	BroadcastMessage(msg_DLAttemptComplete, (void *)mState);	BroadcastMessage(msg_BatchContinue, NULL);	mConnection->RemoveListener(this);	StopBroadcasting();	RemoveListener(oInterestedParty);}void CDownloadThread::ReceivedFileChunk(SProgressMessage *chunkMsg){		if(mState != DS_DOWNLOADING && mState != DS_CANCELLED)	{		// We're not downloading and we're not cancelled - transition to the DOWNLOADING state.		mState = DS_DOWNLOADING;			// Reset the download statistics variables.		iLastChunkTickCount = ::TickCount();		iLastChunkSizeBytes = 0;		iLastChunkTotalCompletedBytes = 0;		iElapsedTicks = 0;		// If we have a known destination here, this is a batch download.				bool isBatchDownload = bDestinationIsGood;				// Is this a batch download?		if(isBatchDownload)		{			// Yes. Follow the batch download rules.									// Construct the relative path...			LStr255 path("\p:");			path.Append(mDestination.name);			path.Append("\p:");			path.Append(pRemoteFilename);						// ...then the FSSpec for the output file.			FSSpec localFile;			OSErr result = FSMakeFSSpec(mDestination.vRefNum, mDestination.parID, path, &localFile);			memcpy(&mDestination, &localFile, sizeof(FSSpec));												if(result == -43)			{				// File doesn't exist? Cool, continue.			}			else			{				// File does exist? Flex on what the overwrite local radio button was set to.				if(bOverwriteLocal)					ThrowIfOSErr_(::FSpDelete(&localFile));				else					CancelDownload(DS_FILEEXISTS);			}		}		else		{			// No. Get the destination.						// Pop up the put file dialog.			StandardFileReply fileReply;			::StandardPutFile(LStr255(strN_UIStrings, strN_UI_SelectDLFolder), pRemoteFilename, &fileReply);					// Only proceed if the user hits OK.			if(fileReply.sfGood) 			{				if(fileReply.sfReplacing)				{					// User agreed to replace the existing file.					ThrowIfOSErr_(::FSpDelete(&fileReply.sfFile));				}				memcpy(&mDestination, &fileReply.sfFile, sizeof(FSSpec));				bDestinationIsGood = true;							}			else			{				// Cancel the download in progress.				bDestinationIsGood = false;				CancelDownload(DS_CANCELLED);			}		}				OSType creator, fileType;		CUrlHelper::GetFourCCCodes(mDestination.name, &creator, &fileType);		mDownloadFile.SetSpecifier(mDestination);		mDownloadFile.CreateNewDataFile(creator, fileType, smSystemScript);		mDownloadFile.OpenDataFork(fsWrPerm);	}		// Process the downloaded chunk if we're downloading.	if(mState != DS_CANCELLED || mState != DS_FILEEXISTS)	{			if(chunkMsg->totalBytes)		{			UpdateDLProgress(chunkMsg);		}		else		{			// Don't know how long the download is.			sprintf(statusText, "Received: %lu k", chunkMsg->completedBytes/1024);			DisplayProgress(statusText);		}				// Save the downloaded chunk.		LHTTPMessage *responseMsg = mHttpResponse.GetReturnMessage();			LDynamicBuffer *responseBuf = responseMsg->GetInternalMessageBody();				// Flush the response buffer to the destination file.		long written = responseBuf->GetBufferLength();		Handle hChunkData = responseBuf->GetBufferDataH();		mDownloadFile.PutBytes(*hChunkData, written);				// Did we write all data?		if(written != responseBuf->GetBufferLength())		{			Throw_(-34);		}		else		{			iDownloadSaveResult = 0;		}				responseBuf->ResetBuffer(); // empty the buffer		DisposeHandle(hChunkData);	}	}void CDownloadThread::UpdateDLProgress(SProgressMessage *progress){	UInt64 currentChunkTicks = ::TickCount();		// 60 ticks per second, so how many ticks did it take to download this chunk?	UInt64 ticksSinceLastChunk = currentChunkTicks - iLastChunkTickCount;	iElapsedTicks += ticksSinceLastChunk;	// And how many bytes did we download in that time?	UInt64 bytesInThisChunk = progress->completedBytes - iLastChunkTotalCompletedBytes;	UInt64 bytesPerTick = bytesInThisChunk / ticksSinceLastChunk;		// Turn that into bytes per second.	// TODO: use fixed-point instead	float multiplier = 60.0 / ticksSinceLastChunk;	float bytesPerSecond = bytesInThisChunk * multiplier;	// And update the counters.	iLastChunkTickCount = currentChunkTicks;	iLastChunkTotalCompletedBytes = progress->completedBytes;		float temp1 = progress->completedBytes;	float temp2 = progress->totalBytes;	UInt32 thePercentage = (temp1/temp2) * 100;	if (thePercentage > 100)		thePercentage = 100;	UInt32 theTotalK = (progress->totalBytes/1024);	UInt32 KBsec = lround(bytesPerSecond / 1024);	if(isinf(bytesPerSecond)) KBsec = 0; 	sprintf(statusText, "Received: %lu%% of %luKB (%lu kB/sec)", 				thePercentage, 				theTotalK,				KBsec);					UpdateProgressBar(thePercentage);	DisplayProgress(statusText);}void CDownloadThread::CancelDownload(DOWNLOAD_STATE state){	// Abort the download.	bSuccess = false;		mState = state;	try {		mConnection->Abort();	}	catch (...)	{			// we expect an exception here	}	BroadcastMessage(msg_DLAttemptComplete, (void *)mState);	UpdateProgressBar(0);		sprintf(statusText, p2cstr(LStr255(strN_Progress, strN_Prog_Cancelled)));	DisplayProgress(statusText);		SysBeep(30);}void CDownloadThread::UpdateProgressBar(UInt8 percentage){	iProgressPercentage = percentage;	BroadcastMessage(msg_UpdateProgressBar, (void *)iProgressPercentage);}void CDownloadThread::ListenToMessage(MessageT inMessage, void *ioParam){	SProgressMessage * theMsg = (SProgressMessage *) ioParam;			if(!bOverrideStatusMsg)	{		switch(inMessage)		{			case 9999:				CancelDownload(DS_CANCELLED);				break;					case 202:				if(mState == DS_CONNECTING)				{					UpdateProgressBar(0);										sprintf(statusText, p2cstr(LStr255(strN_ConnectionMsgs, strN_Conn_GenericFailure)));					DisplayProgress(statusText);				}				break;					case msg_RetrieveItemFailed:				UpdateProgressBar(0);				mState = DS_FAILURE;				sprintf(statusText, p2cstr(LStr255(strN_Progress, strN_Prog_Failed)), (StringPtr)theMsg->currentItem);				DisplayProgress(statusText);								BroadcastMessage(msg_DLFailure, (void *)-10000);				break;			case msg_RetrieveItemSuccess:				// Handle the race condition between the cancellation message and the completion message.				if(mState != DS_CANCELLED)				{					mState = DS_SUCCESS;					UpdateProgressBar(100);					BroadcastMessage(msg_DLSuccess, NULL);					iFileSize = theMsg->totalBytes;					}						break;						case msg_OpeningConnection:				UpdateProgressBar(0);				mState = DS_CONNECTING;				sprintf(statusText, p2cstr(LStr255(strN_Progress, strN_Prog_Open)), (StringPtr)theMsg->currentItem);				DisplayProgress(statusText);				break;			case msg_Connected:				UpdateProgressBar(0);								mState = DS_CONNECTED;				sprintf(statusText, p2cstr(LStr255(strN_Progress, strN_Prog_Connected)), (StringPtr)theMsg->currentItem);				DisplayProgress(statusText);					break;							case msg_ReceivingData:							if(theMsg->statusCode != 200)				{					return; // we're not downloading, we're getting some other message...				}								if(bSavingFile)					ReceivedFileChunk(theMsg);					/*				// TODO: de-spaghettify				if(bSavingFile && mState != DS_DOWNLOADING && mState != DS_CANCELLED)				{					mState = DS_DOWNLOADING;					// We're now connected and receiving data.					Str255 strRemoteFilename;					StandardFileReply fileReply;					CUrlHelper::GetRemoteFilename(strRemoteFilename, pRemoteUrl);										// If this is a batch download, skip this and use the batch destination.					if(bDestinationIsGood == false)					{						::StandardPutFile(LStr255(strN_UIStrings, strN_UI_SelectDLFolder), pRemoteFilename, &fileReply);											// Only proceed if the user hits OK.						if(fileReply.sfGood) 						{							if(fileReply.sfReplacing)							{								// User agreed to replace the existing file.								ThrowIfOSErr_(::FSpDelete(&fileReply.sfFile));							}							memcpy(&mDestination, &fileReply.sfFile, sizeof(FSSpec));							bDestinationIsGood = true;												}						else						{							// cancel the download in progress							bDestinationIsGood = false;							CancelDownload(DS_CANCELLED);						}					}					else					{						// This is a batch download. Follow the batch rules.												FSSpec localFile;						LStr255 path("\p:");						path.Append(mDestination.name);						path.Append("\p:");						path.Append(pRemoteFilename);												OSErr result = FSMakeFSSpec(mDestination.vRefNum, mDestination.parID, path, &localFile);						memcpy(&mDestination, &localFile, sizeof(FSSpec));																		if(result == -43)						{							// File doesn't exist? Cool, continue.						}						else						{							if(bOverwriteLocal)							{								// File does exist? Flex on what the overwrite local radio button was set to.								ThrowIfOSErr_(::FSpDelete(&localFile));							}							else							{								// Skip this download.								CancelDownload(DS_FILEEXISTS);								break;							}						}					}											iLastChunkTickCount = ::TickCount();					iLastChunkSizeBytes = 0;					iLastChunkTotalCompletedBytes = 0;					iElapsedTicks = 0;				}											if(mState != DS_CANCELLED || mState != DS_FILEEXISTS)				{					if(theMsg->totalBytes)					{						UInt64 currentChunkTicks = ::TickCount();												// 60 ticks per second, so how many ticks did it take to download this chunk?						UInt64 ticksSinceLastChunk = currentChunkTicks - iLastChunkTickCount;						iElapsedTicks += ticksSinceLastChunk;						// And how many bytes did we download in that time?						UInt64 bytesInThisChunk = theMsg->completedBytes - iLastChunkTotalCompletedBytes;						UInt64 bytesPerTick = bytesInThisChunk / ticksSinceLastChunk;												// Turn that into bytes per second.						// TODO: use fixed-point instead						float multiplier = 60.0 / ticksSinceLastChunk;						float bytesPerSecond = bytesInThisChunk * multiplier;										// And update the counters.						iLastChunkTickCount = currentChunkTicks;						iLastChunkTotalCompletedBytes = theMsg->completedBytes;												float temp1 = theMsg->completedBytes;						float temp2 = theMsg->totalBytes;						UInt32 thePercentage = (temp1/temp2) * 100;						if (thePercentage > 100)							thePercentage = 100;						UInt32 theTotalK = (theMsg->totalBytes/1024);						UInt32 KBsec = lround(bytesPerSecond / 1024);						if(isinf(bytesPerSecond)) KBsec = 0; 						sprintf(statusText, "Received: %lu%% of %luKB (%lu kB/sec)", 									thePercentage, 									theTotalK,									KBsec);															UpdateProgressBar(thePercentage);					}					else					{						// Don't know how long the response is.						sprintf(statusText, "Received: %lu k", theMsg->completedBytes/1024);					}										DisplayProgress(statusText);				}				*/						default:				break;		}	}}// ---------------------------------------------------------------------------//		¥ DisplayProgress// ---------------------------------------------------------------------------// -- used to display the progress message on the UIvoidCDownloadThread::DisplayProgress(char * theStatus){	CopyCStringToPascal(theStatus, pStatusText);	BroadcastMessage(msg_UpdateProgressText, (void *)pStatusText);	Yield();}void CDownloadThread::DisplayProgress(LStr255 theStatus){	BroadcastMessage(msg_UpdateProgressText, (void *)theStatus);	Yield();}void CDownloadThread::ProcessDownloadedFile(LHTTPResponse *){	mDownloadFile.CloseDataFork();	::FlushVol(NULL, 0);		// Is this a MacBinary file?	iMacBinaryDecodeResult = 0;	if(bDecodeMacBinary && FSpIsMacBinary(&mDestination))		DecodeMacBinary(&mDestination);}void CDownloadThread::DecodeMacBinary(FSSpec *spec){	iMacBinaryDecodeResult = DecodeMacBinaryFile(spec);	if(iMacBinaryDecodeResult == noErr)		bMacBinaryWasDecoded = true;}