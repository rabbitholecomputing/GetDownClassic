#include "CBatchDownloadDialog.h"#include "CBasicApp.h"const ResIDT msg_Browse 		= 1000;const ResIDT msg_Destination 	= 1001;const ResIDT msg_ImportURL		= 1002;CBatchDownloadDialog::CBatchDownloadDialog(){	bBatchDownloadInProgress = false;	iNumBatchUrls = 0;}void CBatchDownloadDialog::UpdateTableData(CBatchDownloadUrlTable *table){	TableIndexT rows, cols;		table->GetTableSize(rows, cols);	table->RemoveRows(rows, 0);	for(int i=0; i<iNumBatchUrls; i++)	{		table->InsertRows(1, i, &batchUrls[i]);	}	table->Refresh();}#define kCR		'\r'#define kNL		'\n'size_t CBatchDownloadDialog::ReadLineFromStream(LStream *stream, Str255 outLine){	// Read until a newline.	char c;	char url[256];	long byteCount = 1;	int pos = 0;		memset(url, 0, 256);		while(c != kCR && c != kNL)	{			if(pos == 255) break;			byteCount = 1;		stream->GetBytes(&c, byteCount);				// TODO: URL-encode anything that's not alphanumeric.		url[pos] = c;		pos++;						if(byteCount == 0) break;	}	url[pos-1] = 0;	CopyCStringToPascal(url, outLine);		// Peek the next character - if it's \n, eat it.	stream->PeekData(&c, byteCount);	if(c == '\n') stream->GetBytes(&c, byteCount);		return pos-1;}void CBatchDownloadDialog::PerformImport(Handle hData){	int urlNum = 0;	Str255 url;	size_t bytesRead = -1;		LHandleStream importFile(hData);		while(urlNum != kMaxBatchUrls)	{		if(importFile.AtEnd()) break;			bytesRead = ReadLineFromStream(&importFile, url);		if(bytesRead == 0) break;		LStr255::CopyPStr(url, batchUrls[urlNum].url);		batchUrls[urlNum].status = BDL_TODO;		urlNum++;	}		iNumBatchUrls = urlNum;	if(iNumBatchUrls > 7)	{		((LScroller *)batchDialog->GetDialog()->FindPaneByID(1001))->Enable();	}	else	{		((LScroller *)batchDialog->GetDialog()->FindPaneByID(1001))->Disable();	}}void CBatchDownloadDialog::PerformImport(FSSpec *fsSpec){	// Load the file.	LFileStream importFile(*fsSpec);	importFile.OpenDataFork(fsRdPerm);		int urlNum = 0;	Str255 url;		size_t bytesRead = -1;		while(urlNum != kMaxBatchUrls)	{		if(importFile.AtEnd()) break;			bytesRead = ReadLineFromStream(&importFile, url);		if(bytesRead == 0) break;		LStr255::CopyPStr(url, batchUrls[urlNum].url);		batchUrls[urlNum].status = BDL_TODO;		urlNum++;	}}void CBatchDownloadDialog::Show(){	bool cancelled = false;	for(int i=0; i<kMaxBatchUrls; i++)	{		batchUrls[i].url[0] = 0;		batchUrls[i].status = BDL_TODO;	}			batchDialog = new StDialogHandler(PPob_BatchDownloadDialog, this);	CBatchDownloadUrlTable *table = (CBatchDownloadUrlTable *)batchDialog->GetDialog()->FindPaneByID(1000);	UpdateTableData(table);		while (true) {		MessageT hitMessage = batchDialog->DoDialog();		if (hitMessage == msg_Cancel)		{			cancelled = true;			break;		}		else if (hitMessage == msg_OK)		{			cancelled = false;						//((LStdButton *)batchDialog->GetDialog()->FindPaneByID(1))->Disable();			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(2))->Disable();			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(3))->Disable();			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(4))->Disable();			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(5))->Disable();			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(7))->Disable();			((LStdRadioButton *)batchDialog->GetDialog()->FindPaneByID(5))->Disable();			((LStdRadioButton *)batchDialog->GetDialog()->FindPaneByID(6))->Disable();						bOverwriteLocal = (((LStdRadioButton *)batchDialog->GetDialog()->FindPaneByID(5))->GetValue() == 0);						BeginBatchDownload(batchDialog);						//((LStdButton *)batchDialog->GetDialog()->FindPaneByID(1))->Enable();			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(2))->Enable();			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(3))->Enable();			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(4))->Enable();			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(5))->Enable();			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(7))->Enable();			((LStdRadioButton *)batchDialog->GetDialog()->FindPaneByID(5))->Enable();			((LStdRadioButton *)batchDialog->GetDialog()->FindPaneByID(6))->Enable();		}		else if (hitMessage == msg_Browse)		{			StandardFileReply fileReply;			SFTypeList textType;			textType[0] = OSType('TEXT');			::StandardGetFile(nil, 1, textType, &fileReply);						if(fileReply.sfGood) 			{				PerformImport(&fileReply.sfFile);				UpdateTableData(table);				((LStdButton *)batchDialog->GetDialog()->FindPaneByID(1))->Enable();			}		}		else if (hitMessage == msg_Destination)		{			StandardFileReply fileReply;			UStandardFile::GetDirectory(fileReply);						if(fileReply.sfGood)			{				memcpy(&mDestination, &fileReply.sfFile, sizeof(FSSpec));				((LStdButton *)batchDialog->GetDialog()->FindPaneByID(4))->SetDescriptor(mDestination.name);				((LStdButton *)batchDialog->GetDialog()->FindPaneByID(btn_Local))->Enable();				((LStdButton *)batchDialog->GetDialog()->FindPaneByID(btn_Remote))->Enable();			}		}		else if (hitMessage == msg_ImportURL)		{			ImportBatchFromURL();		}							if(!cancelled)		{						}	}	delete batchDialog;}void CBatchDownloadDialog::ImportBatchFromURL(){	batchImportRemoteDialog = new CUrlImportDialogHandler(PPob_BatchRemoteImportDialog, this);	bInBatchUrlDialog = true;		bool breakFlag = false;		MessageT hitMessage; 	bool hasShownSuccessOrFailure = false;	batchImportRemoteDialog->ResetSemaphores();	while (breakFlag == false) {		hitMessage = batchImportRemoteDialog->DoDialog();			switch(hitMessage)		{			case msg_Cancel:				breakFlag = true;				mDownloadClient.StopDownloadProcess();				break;			case msg_OK:			{				// Start the download procedure...								CPreferencesDialog prefsDialog;				Str255 strRemoteUrl;								batchImportRemoteDialog->ResetSemaphores();				((LStdButton *)batchImportRemoteDialog->GetDialog()->FindPaneByID(1))->Disable();				((LEditField *)batchImportRemoteDialog->GetDialog()->FindPaneByID(1001))->GetDescriptor(strRemoteUrl);				mDownloadClient.BeginDownloadProcess(batchImportRemoteDialog, prefsDialog.GetCurrentPreferences(), strRemoteUrl, false, false, NULL, false);				break;			}						case msg_UpdateProgressText:				((LCaption *)batchImportRemoteDialog->GetDialog()->FindPaneByID(4))->					SetDescriptor((StringPtr)batchImportRemoteDialog->GetInParam());				break;					default:				break;		}				// Check our semaphores.		if(batchImportRemoteDialog->GetBatchDataAvailable())		{			PerformImport((Handle)batchImportRemoteDialog->GetBatchDataHandle());				CBatchDownloadUrlTable *table = (CBatchDownloadUrlTable *)batchDialog->GetDialog()->FindPaneByID(1000);			UpdateTableData(table);			((LStdButton *)batchDialog->GetDialog()->FindPaneByID(1))->Enable();				breakFlag = true;		}	}		delete batchImportRemoteDialog;}void CBatchDownloadDialog::BeginBatchDownload(StDialogHandler *batchDialog){	CBatchDownloadUrlTable *table = (CBatchDownloadUrlTable *)batchDialog->GetDialog()->FindPaneByID(1000);	LEditField *sourceUrl = (LEditField *)parent->GetWindow()->FindPaneByID(pane_EditField_SourceURL);	bNextDownloadCanBegin = false;	bBatchDownloadInProgress = true;		LStr255 btnCancel = "\pCancel";	((LStdButton *)batchDialog->GetDialog()->FindPaneByID(1))->SetDescriptor(btnCancel);		AddListener(parent);	StartBroadcasting();		bool keepDownloading = true;		for(iBatchSequenceNum=0; iBatchSequenceNum<kMaxBatchUrls; iBatchSequenceNum++)	{		if(batchUrls[iBatchSequenceNum].url[0] == 0) break;			sourceUrl->SetDescriptor(batchUrls[iBatchSequenceNum].url);		sourceUrl->Refresh();		BroadcastMessage(msg_DownloadButton, NULL);					batchUrls[iBatchSequenceNum].status = BDL_STARTED;		UpdateTableData(table);		table->Refresh();				// Block until this download attempt is complete...			bNextDownloadCanBegin = false;		bool ready = false;				while(keepDownloading)		{			LThread::EnterCritical();			ready = bNextDownloadCanBegin;			LThread::ExitCritical();			if(ready) break;						// Check for buttons hit on the dialog...			MessageT hitMessage = batchDialog->DoDialog();						switch(hitMessage)			{				case msg_OK:					BroadcastMessage(msg_DownloadButton, NULL);					keepDownloading = false;					break;							default:				break;			}						if(!keepDownloading) break;						LThread::Yield();		}				UpdateTableData(table);		table->Refresh();		table->Draw(nil);				if(keepDownloading == false) break;	}		bBatchDownloadInProgress = false;	LStr255 btnBegin = "\pBegin";	((LStdButton *)batchDialog->GetDialog()->FindPaneByID(1))->SetDescriptor(btnBegin);}void CBatchDownloadDialog::SetCurrentDownloadStatus(DOWNLOAD_STATE state){	switch(state)	{		case DS_SUCCESS:		batchUrls[iBatchSequenceNum].status = BDL_SUCCESS;		break;		case DS_FAILURE:		batchUrls[iBatchSequenceNum].status = BDL_FAILURE;		break;		case DS_CANCELLED:		batchUrls[iBatchSequenceNum].status = BDL_CANCELLED;		break;		case DS_FILEEXISTS:		batchUrls[iBatchSequenceNum].status = BDL_EXISTS;		break;	}}